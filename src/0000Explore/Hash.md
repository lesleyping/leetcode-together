# 哈希集合
## 1.存在重复元素
给定一个整数数组，判断是否存在重复元素。

如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。

## 2.只出现一次的数字
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

- 遍历，第一次出现添加，第二次出现删除
- 异或：- 异或具有交换性；0 ^ 任何数 = 任何数
- 排序
## 3.两个数组的交集
给定两个数组，编写一个函数来计算它们的交集。
- 哈希表
- 排序，外排


## 4.快乐数
编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。

如果 n 是快乐数就返回 True ；不是，则返回 False 。
- 哈希表存储数字，非快乐数会进入循环，但不是因为1
- 快慢指针


# 哈希映射

## 5.两数之和
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
- 暴力
- 两遍哈希表
- 一遍哈希表

## 6.同构字符串
给定两个字符串 s 和 t，判断它们是否是同构的。

如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。

所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。
- 两个哈希表存储对应关系

## 7.两个列表的最小索引总和
假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。

你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。

- 判断等于要在小于号之前

## 8.字符串中的第一个唯一字符
给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

## 9.两个数组的交集 II
给定两个数组，编写一个函数来计算它们的交集。
- 哈希表
- 排序后双指针

## 10.存在重复元素 II
给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。
- hashmap
- 维持一个大小刚好为k的哈希set

# 设计键
## 11.字母异位词分组
给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

- 字符串排序

## 12.有效的数独
判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

- 如何遍历子数独

> 可以使用`box_index = (row / 3) * 3 + col / 3`

- 使用3个 9*9 大小的数组，同时保存行列信息

## 13.寻找重复的子树
给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。

两棵树重复是指它们具有相同的结构以及相同的结点值。

- 设计键为String
- 通过DFS完成

[设计键](https://leetcode-cn.com/leetbook/read/hash-table/xxavl2/)
- 当字符串 / 数组中每个元素的顺序不重要时，可以使用排序后的字符串 / 数组作为键。
- 如果只关心每个值的偏移量，通常是第一个值的偏移量，则可以使用偏移量作为键。
- 在树中，你有时可能会希望直接使用 TreeNode 作为键。 但在大多数情况下，采用子树的序列化表述可能是一个更好的主意。
- 在矩阵中，你可能希望使用行索引或列索引作为键。
- 在数独中，可以将行索引和列索引组合来标识此元素属于哪个块。
- 有时，在矩阵中，您可能希望将值聚合在同一对角线中。
(i+j)(i-j)

# 小结
## 14.宝石与石头
 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。

J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此"a"和"A"是不同类型的石头。

- hashSet

## 15.无重复字符的最长子串
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
- 模拟滑动窗口

## 16.四数相加 II
给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。
- 两个哈希表

## 17.前 K 个高频元素[TopK问题][难]
给定一个非空的整数数组，返回其中出现频率前 k 高的元素。
- 最小堆（写bug写了太久呜呜呜）
- (计数)桶排序
[还有快排变形、二叉树搜索的解法，但我个人认为先掌握好堆排序]
[TODO]

## 18.常数时间插入、删除和获取随机元素[难]
设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构。

insert(val)：当元素 val 不存在时，向集合中插入该项。
remove(val)：元素 val 存在时，从集合中移除该项。
getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。
- 此题的正确解法是利用到了一个一维数组和一个 HashMap，其中数组用来保存数字，HashMap 用来建立每个数字和其在数组中的位置之间的映射。

- 插入操作——先看这个数字是否已经在 HashMap 中存在，如果存在的话直接返回 false，不存在的话，将其插入到数组的末尾，然后建立数字和其位置的映射（map的第一个参数是元素的值，第二个参数是该值在数组中的下标）

- 删除操作——比较 tricky 的，还是要先判断其是否在 HashMap 里，如果没有，直接返回 false。由于 HashMap 的删除是常数时间的，而数组并不是，为了使数组删除也能常数级，实际上将要删除的数字和数组的最后一个数字调换个位置，然后修改对应的 HashMap 中的值，这样只需要删除数组的最后一个元素即可，保证了常数时间内的删除

- 返回随机数——对于数组来说就很简单了，只要随机生成一个位置，返回该位置上的数字即可