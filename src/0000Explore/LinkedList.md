[链表里有很多递归，需要搞清楚点]
# 双指针技巧
## 1.环形链表
给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。
- 双指针
    - 慢指针每次移动一步，而快指针每次移动两步。如果列表中不存在环，最终快指针将会最先到达尾部，此时我们可以返回 false。

    - 现在考虑一个环形链表，把慢指针和快指针想象成两个在环形赛道上跑步的运动员（分别称之为慢跑者与快跑者）。而快跑者最终一定会追上慢跑者。这是为什么呢？考虑下面这种情况（记作情况 A）- 假如快跑者只落后慢跑者一步，在下一次迭代中，它们就会分别跑了一步或两步并相遇。
    - 其他情况又会怎样呢？例如，我们没有考虑快跑者在慢跑者之后两步或三步的情况。但其实不难想到，因为在下一次或者下下次迭代后，又会变成上面提到的情况 A。
- 哈希表
    - 我们遍历所有结点并在哈希表中存储每个结点的引用（或内存地址）。如果当前结点为空结点 null（即已检测到链表尾部的下一个结点），那么我们已经遍历完整个链表，并且该链表不是环形链表。如果当前结点的引用已经存在于哈希表中，那么返回 true（即该链表为环形链表）。

## 2.环形链表Ⅱ
给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

说明：不允许修改给定的链表。
- 创造双指针的两次相遇。假定有环，其中，head到环入口a个节点，环有b个节点

    - 第一次相遇时，满足两个条件：fast = 2 * slow；fast = slow + nb（fast移动2个，slow移动一个）
    - 计算得到 fast = 2nb，slow = nb
    - 此时将fast移动到head，slow不变；两指针再同时走a步即可到达入口，此时两者相遇
    - __这里的fast移动后作为一个度量a长度的指针__

## 3.相交链表
编写一个程序，找到两个单链表相交的起始节点。
- 我们需要做的事情是，让两个链表从同距离末尾同等距离的位置开始遍历。这个位置只能是较短链表的头结点位置。
    - 为此，我们必须消除两个链表的长度差

    - 指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历
    - 如果 pA 到了末尾，则 pA = headB 继续遍历
    - 如果 pB 到了末尾，则 pB = headA 继续遍历
    - 比较长的链表指针指向较短链表head时，长度差就消除了
    - 如此，只需要将最短链表遍历两次即可找到位置

## 4.删除链表的倒数第N个节点
给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。
- 双指针一次遍历   [__哑结点很重要！！__]

# 经典问题
## 5.反转链表
反转一个单链表。
- 双指针：前后指针
- 迭代：关键点 head.next.next = head

## 6.移除链表元素
删除链表中等于给定值 val 的所有节点。
- 哑节点
- 递归

## 7.奇偶链表
给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。
- 奇偶两个链表头

## 8.回文链表
请判断一个链表是否为回文链表。
- 快慢指针找到中点位置，同时反转前半部分链表；找到中间后开始比较

# 双链表
## 9.合并两个有序链表
将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
- 迭代
- 递归？

## 10.两数相加
给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
- 模拟加法

## 11.扁平化多级双向链表
多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。

给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。
- 迭代法：注意把当前节点的child设置为null
- 递归

## 12.复制带随机指针的链表
给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。

要求返回这个链表的 深拷贝。 

我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：

val：一个表示 Node.val 的整数。
random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。
- DFS
- BFS
- 找到所有节点，再链接
- 原地分裂

## 13.旋转链表
给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。
- 首先遍历链表，得到len和最后的节点，并连接到表头
- 然后计算从哪里开始断掉